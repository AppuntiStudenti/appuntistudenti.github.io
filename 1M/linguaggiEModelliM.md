Materiale
---------

Domande Esame
-------------

Dato un ASF, scrivere la Grammatica DX e SX

- Di che tipo è il Linguaggio L={1^n2^2n3^m, n>1,m>1} e se cambio m in n di che tipo è?
- Chiusure JS e a cosa servono
- Architettura del Parser LR
- Proprietà delle reti di petri e Touring equivalenza
- Prototipi in Java
- Modello call by value e call by name

Il prof cerca di metterti a tuo agio è veramente bravo :)

---

- Dato un ASF scrivere grammatica destra e sinistra?
- Di che tipo è il linguaggio L={a^n b^2n c^m, n>1, m>0}? Se cambio m con n come diventa? Come lo dimostro?
- Proprietà delle Reti di Petri e Touring-equivalenza, relazione con ASF
- Call-by-name e call-by-value
- Chiusure
- Parser LR
- Computabilità e Halt MdT
 
Tutto in 15 minuti. Orale tranquillissimo!!
 
--- 
 
- Di che tipo è la grammatica a^n b^3n+1 c^m
- E se fosse stata c^n al posto di c^m???
- Reti di petri perchè non sono turing equivalenti e perche non vogliamo che lo siano???
- Computabilità e halt di turing??
- Chiusure cosa sono e cosa servono??
- Struttura parser LR??
- Call by value vs call by name e come devo fare se voglio usare la call by name nei "classici" linguaggi???
 
Orale rapidissimo! lui ti mette a tuo agio e dimostrate familiarità e siate sicuri x avere un buon voto!!!!
 
---
 
- Di che tipo sono le grammatiche: a^m b^m c^(2m) , M>1 - a^m c^(2m) , M>1
- E per quale lemma possiamo affermarlo?
- Dato un ASF disegnare regole lineari sinistre e destre?
- Proprietà delle Reti di Petri e touring equivalenza?
- Prototipi java (come si possono modificare e quali sono le ripercussioni su oggetti già creati e su quelli ancora da creare)?
 
---

- Dato un automa, scrivere le grammatiche
- Dato un linguaggio dire il tipo
- HALT di Touring
- Prototipi JS
- Chiusure JS
- Turing Equiv di Reti di Petri
- Pumping Lemma
- Equiv di Reti di Petri ad ASF
- Modello call by name e by value
- Vitalità e suo utilizzo
- Deadlock in una rete di Petri
- Test a zero e perché non vogliamo finire nella turing equivalenza

---
 
3/07/2013 
 
 mi ha disegnato un asf, e chiesto di inserire delle produzioni a caso e calcolare grammatica regolare a sinistra e a destra (interpretazione top down e botton up). attenzione agli archi in ingresso allo stato iniziale e in uscita dallo stato finale ( bisogna considerare gli stati come transito e come stato finale o rispettivamente iniziale)
 
- mi ha dato un linguaggio {a^n b^2n c^r: n>0, r>0} e mi ha chiesto di dirgli il tipo , e una volta  detto che era di tipo2  (a^n b^n è un prefisso di tipo2, i mattoncini che crescono simmetricamente, r non è legato a n bla bla bla..). mi ha chiesto se modificando l'esponente r in n che tipo era? tipo1 (perchè con le produzioni di tipo 2 non posso mappare uno scambio). e quale fonte teorica mi consente di dimostrare che non posso renderlo di tipo2 -> pumping lemma
- chiusure principio in generale, che utilità hanno.
 
- cos'è che impedisce al formalismo standard di petri di essere turing equivalente? test a zero. mi ha detto di citare le estensioni, e cosa comporta estendere il formalismo base -> turing equivalenza -> proprietà indecidibili.
 
- è possibile risolvere il test a zero senza estenderla? sì se k limitata, perchè? perchè se è k limitata avrà sempre un numero di marcature limitate = stati finiti = ASF con un'altra faccia (asf mi da sempre una risposta!)
 
-struttura parser lr(0) (oracolo stack e controller) a grandi linee. poi mi ha chiesto se non fosse una contraddizione che l'oracolo fosse realizzato con un asf ma riconoscesse linguaggi di tipo2? risposta: no perchè combinato con lo stack costituisce la macchina di riferimento per il tipo2.
 
orale tranquillissimo, durata 20', il prof ti lascia pensare e fa in tutti i modi per fartelo affrontare con ottimi risultati (le domande sono standard -> vedi universibo)...
 
---
 
03/07/2013

- Dato un automa scrivere le grammatiche destra e sinistra.
- Dato il linguaggio generato da a^n b^2n c^m, dire di che tipo è (ovviamente motivandolo). E se invece fosse a^n b^2n c^n ? Dire cosa cambia con motivazione intuitiva e pumping lemma
- Differenza tra i modelli call-by-name, call-by-value. Vantaggi dell'uno e dell'altro, quale è più utilizzato e perchè e spiegare se si potrebbe usare l'altro.
- Prototype-based inhertance: quali modifiche possono essere apportare all'oggetto prototipo e come influiscono sugli oggetti già creati.
- Reti di petri: perchè non sono turing equivalenti? Cosa non riescono ad esprimere? Qual'è il vantaggio che si ha mantenendo la non-turing-equivalenza? E se la rete fosse limitata di potrebbe esprimere il test a zero?
 
---
 
26/07/2013

- L = {1^n 2^2n 3^m } che tipo di linguaggio è? Cosa sarebbe cambiato se fosse stato L = {1^n 2^2n 3^3n } (Spiegazione informale e rapida presentazione informale del pumping lemma con accenno al fatto che sia una condizione necessaria che si usa in negativo). 
- Reti di Petri: proprietà e decidibilità, similitudine/equivaleza con ASF, touring equivalenza (presentazione rapida delle proprietà delle reti, quando è equivalente ad un ASF, quando è equivalente ad una MdT e decidibilità delle proprietà).
- Halt della MdT (molto superficialmente)
- Javascript costruttore "Function", Call-by-name VS Call-by-value, prototipi, type augmenting, creazione delle strutture gerarchiche dei prototipi, chiusure.
 
Il tutto è durato 10 minuti al massimo, ditegli quello che vuole sentirsi dire e in pochissimo siete fuori con un ottimo voto.
